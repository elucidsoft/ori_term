//! Terminal grid: 2D cell storage with cursor, scrollback, and dirty tracking.
//!
//! The `Grid` is the central data structure for terminal emulation. It stores
//! visible rows, manages cursor state, and tracks tab stops. Scrollback,
//! dirty tracking, and editing operations are added in submodules.

pub mod cursor;
pub mod dirty;
pub mod editing;
pub mod navigation;
pub mod ring;
pub mod row;
pub mod scroll;

use std::ops::{Index, IndexMut, Range};

use crate::index::Line;

pub use cursor::{Cursor, CursorShape};
pub use dirty::DirtyTracker;
pub use editing::EraseMode;
pub use navigation::TabClearMode;
pub use ring::ScrollbackBuffer;
pub use row::Row;

/// The 2D terminal cell grid.
///
/// Stores visible rows indexed `0..lines` (top to bottom), a cursor,
/// tab stops, scrollback history, and dirty tracking for damage-based
/// rendering.
#[derive(Debug, Clone)]
pub struct Grid {
    /// Visible rows (index 0 = top of screen).
    rows: Vec<Row>,
    /// Number of columns.
    cols: usize,
    /// Number of visible lines.
    lines: usize,
    /// Current cursor position and template.
    cursor: Cursor,
    /// DECSC/DECRC saved cursor.
    saved_cursor: Option<Cursor>,
    /// Tab stop at each column (true = stop).
    tab_stops: Vec<bool>,
    /// DECSTBM scroll region: top (inclusive) .. bottom (exclusive).
    scroll_region: Range<usize>,
    /// Scrollback history (rows that scrolled off the top).
    scrollback: ScrollbackBuffer,
    /// How many lines scrolled back into history (0 = live view).
    display_offset: usize,
    /// Tracks which rows have changed since last drain.
    dirty: DirtyTracker,
}

impl Grid {
    /// Create a new grid with the given dimensions.
    ///
    /// Initializes all rows as empty, cursor at (0, 0), and tab stops
    /// every 8 columns.
    pub fn new(lines: usize, cols: usize) -> Self {
        debug_assert!(lines >= 1 && cols >= 1, "Grid dimensions must be >= 1 (got {lines}x{cols})");
        let rows = (0..lines).map(|_| Row::new(cols)).collect();
        let tab_stops = Self::init_tab_stops(cols);

        Self {
            rows,
            cols,
            lines,
            cursor: Cursor::new(),
            saved_cursor: None,
            tab_stops,
            scroll_region: 0..lines,
            scrollback: ScrollbackBuffer::new(ring::DEFAULT_MAX_SCROLLBACK),
            display_offset: 0,
            dirty: DirtyTracker::new(lines),
        }
    }

    /// Number of visible lines.
    pub fn lines(&self) -> usize {
        self.lines
    }

    /// Number of columns.
    pub fn cols(&self) -> usize {
        self.cols
    }

    /// Immutable reference to the cursor.
    pub fn cursor(&self) -> &Cursor {
        &self.cursor
    }

    /// Mutable reference to the cursor.
    pub fn cursor_mut(&mut self) -> &mut Cursor {
        &mut self.cursor
    }

    /// Immutable reference to tab stops.
    #[cfg(test)]
    pub(crate) fn tab_stops(&self) -> &[bool] {
        &self.tab_stops
    }

    /// Total lines: visible + scrollback history.
    pub fn total_lines(&self) -> usize {
        self.lines + self.scrollback.len()
    }

    /// How many lines scrolled back into history (0 = live view).
    pub fn display_offset(&self) -> usize {
        self.display_offset
    }

    /// Immutable reference to the scrollback buffer.
    pub fn scrollback(&self) -> &ScrollbackBuffer {
        &self.scrollback
    }

    /// Immutable reference to the dirty tracker.
    pub fn dirty(&self) -> &DirtyTracker {
        &self.dirty
    }

    /// Mutable reference to the dirty tracker.
    pub fn dirty_mut(&mut self) -> &mut DirtyTracker {
        &mut self.dirty
    }

    /// Adjust display offset (positive = scroll back, negative = scroll forward).
    ///
    /// Clamped to `0..=scrollback.len()`.
    pub fn scroll_display(&mut self, delta: isize) {
        let max = self.scrollback.len();
        let current = self.display_offset as isize;
        let target = (current + delta).clamp(0, max as isize) as usize;

        if target != self.display_offset {
            self.display_offset = target;
            self.dirty.mark_all();
        }
    }

    /// Initialize tab stops every 8 columns.
    fn init_tab_stops(cols: usize) -> Vec<bool> {
        (0..cols).map(|c| c % 8 == 0).collect()
    }
}

impl Index<Line> for Grid {
    type Output = Row;

    fn index(&self, line: Line) -> &Row {
        &self.rows[usize::try_from(line.0)
            .expect("negative Line index used on Grid without scrollback")]
    }
}

impl IndexMut<Line> for Grid {
    fn index_mut(&mut self, line: Line) -> &mut Row {
        &mut self.rows[usize::try_from(line.0)
            .expect("negative Line index used on Grid without scrollback")]
    }
}

#[cfg(test)]
mod tests;
